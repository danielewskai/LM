nei_matrix[y, x] <- 1
}
return(list(edges = edges, nei_matrix = nei_matrix))
}
ising(temp = 0.01, graph = lattice.gen(3,3))
neighbours <- function(nei, state) {
tmp <- state[as.logical(nei)]
nb_plus <- sum(tmp == 1)
nb_minus <- length(tmp) - nb_plus
list(nb_minus = nb_minus, nb_plus = nb_plus)
}
ising(temp = 0.01, graph = lattice.gen(3,3))
ising <- function(temp = 0.01, graph = lattice.gen(3, 3), step = 50, mem_ret = FALSE) {
new_state <- function(state, U_vec_step) {
n <- ncol(graph$nei_matrix)
stan <- state
v <- sample.int(n, 1)
nei_plus <- neighbours(graph$nei_matrix[v, ], stan)$nb_plus
nei_minus <- neighbours(graph$nei_matrix[v, ], stan)$nb_minus
prog <- exp(2 * temp * (nei_plus - nei_minus)) / (exp(2 * temp * (nei_plus - nei_minus)) + 1)
if (U_vec_step < prog) {
stan[v] <- 1
} else {
stan[v] <- -1
}
return(stan)
}
state_hash <- function(s) {
sum(2^(0:(length(s) - 1)) * ifelse(s > 0, 1, 0))
}
n <- ncol(graph$nei_matrix)
s_down <- rep(-1, n)
s_up = rep(1, n)
stans <- list(s_up, s_down)
U_vec <- c(runif(1))
k <- 0
memory <- list()
while (k < step) {
U_vec <- append(U_vec, runif(2^(k - 1)))
for (i in 1:2^(k - 1)) {
memory[[length(memory) + 1]] <- list()
}
for (i in (2^k):1) {
# print(i)
stans_new <- list()
for (s in stans) {
# print(s)
memorized <- state_hash(s)
if (is.null(memory[[i]][[as.character(memorized)]])) {
stan <- new_state(s, U_vec[i])
memory[[i]][[as.character(memorized)]] <- stan
stans_new[[length(stans_new) + 1]] <- stan
} else {
stans_new[[length(stans_new) + 1]] <- memory[[i]][[as.character(memorized)]]
}
}
stans <- stans_new
}
k <- k + 1
if (all(stans[[1]] == stans[[2]])) {
if(mem_ret == TRUE) {
return(list(result = stans[[1]], history= memory))
} else {
return(stans[[1]])
}
}
}
}
ising(temp = 0.01, graph = lattice.gen(3,3), mem_ret = TRUE)
ising(temp = 0.01, graph = lattice.gen(3,3), mem_ret = TRUE)$hisory
ising(temp = 0.01, graph = lattice.gen(3,3), mem_ret = TRUE)$history
decode(511)
ising(temp = 0.01, graph = tree.gen(10,2), mem_ret = TRUE)$history
tree.gen <- function(n = 5, branching_factor = 2) {
edges <- list()
nei_matrix <- matrix(0, nrow = n, ncol = n)
add_edges <- function(v, w, branching_factor) {
children <- 0
nx <- sample.int(branching_factor - 1, size = 1)
for (i in 1:nx) {
if (w <= n) {
edges[[length(edges) + 1]] <<- c(v, w)
w <- w + 1
children <- children + 1
} else {
break
}
}
return(w)
}
w <- 2
for (v in 1:(n - 1)) {
w <- add_edges(v, w, branching_factor)
if (w > n) {
break
}
}
for (i in 1:length(edges)) {
x <- edges[[i]][1]
y <- edges[[i]][2]
nei_matrix[x, y] <- 1
nei_matrix[y, x] <- 1
}
return(list(edges = edges, nei_matrix = nei_matrix))
}
ising(temp = 0.01, graph = tree.gen(10,2), mem_ret = TRUE)$history
decode(510)
decode(993)
decode(510)
ising <- function(temp = 0.01, graph = lattice.gen(3, 3), step = 50, mem_ret = FALSE) {
new_state <- function(state, U_vec_step) {
n <- ncol(graph$nei_matrix)
stan <- state
v <- sample.int(n, 1)
nei_plus <- neighbours(graph$nei_matrix[v, ], stan)$nb_plus
nei_minus <- neighbours(graph$nei_matrix[v, ], stan)$nb_minus
prog <- exp(2 * temp * (nei_plus - nei_minus)) / (exp(2 * temp * (nei_plus - nei_minus)) + 1)
if (U_vec_step < prog) {
stan[v] <- 1
} else {
stan[v] <- -1
}
return(stan)
}
state_hash <- function(s) {
sum(2^(0:(length(s) - 1)) * ifelse(s > 0, 1, 0))
}
n <- ncol(graph$nei_matrix)
s_down <- rep(-1, n)
s_up = rep(1, n)
U_vec <- c(runif(1))
k <- 0
memory <- list()
while (k < step) {
stans <- list(s_up, s_down)
U_vec <- append(U_vec, runif(2^(k - 1)))
for (i in 1:2^(k - 1)) {
memory[[length(memory) + 1]] <- list()
}
for (i in (2^k):1) {
# print(i)
stans_new <- list()
for (s in stans) {
# print(s)
memorized <- state_hash(s)
if (is.null(memory[[i]][[as.character(memorized)]])) {
stan <- new_state(s, U_vec[i])
memory[[i]][[as.character(memorized)]] <- stan
stans_new[[length(stans_new) + 1]] <- stan
} else {
stans_new[[length(stans_new) + 1]] <- memory[[i]][[as.character(memorized)]]
}
}
stans <- stans_new
}
k <- k + 1
if (all(stans[[1]] == stans[[2]])) {
if(mem_ret == TRUE) {
return(list(result = stans[[1]], history= memory))
} else {
return(stans[[1]])
}
}
}
}
ising(temp = 0.01, graph = tree.gen(10,2), mem_ret = TRUE)
ising(temp = 0.01, graph = tree.gen(10,2))
ising(temp = 0.01, graph = tree.gen(10,2))
ising(temp = 0.01, graph = tree.gen(10,2), mem_ret = TRUE)
ising(temp = 0.01, graph = tree.gen(10,2), mem_ret = TRUE)$history
mem <- ising(temp = 0.01, graph = tree.gen(10,2), mem_ret = TRUE)$history
end(mem)
mem
decode(1023)
size = 1.3
numeric(size)
numeric(size)
numeric(4)
decode <- function(s, n = 1){
if(s == 0){
return(rep(-1,n))
}
v <- numeric(n)
for(k in 1:n){
v[k] <- s %% 2
s <- floor(s/2)
}
return(2*v-1)
}
decode(1023)
decode(1023, 10)
decode(1023, 12)
ising(temp = 0.01, graph = lattice.gen(3,3))
ising(temp = 0.01, graph = lattice.gen(4,4))
ising(temp = 0.01, graph = lattice.gen(5,5))
history <- ising(temp = 0.3, lattice.gen(4,4), mem_ret = TRUE)$history
history
1:length(history)
length(history)
history[[2]]
state_hash <- function(s) {
sum(2^(0:(length(s) - 1)) * ifelse(s > 0, 1, 0))
}
ising <- function(temp = 0.01, graph = lattice.gen(3, 3), step = 50, mem_ret = FALSE) {
new_state <- function(state, U_vec_step) {
n <- ncol(graph$nei_matrix)
stan <- state
v <- sample.int(n, 1)
nei_plus <- neighbours(graph$nei_matrix[v, ], stan)$nb_plus
nei_minus <- neighbours(graph$nei_matrix[v, ], stan)$nb_minus
prog <- exp(2 * temp * (nei_plus - nei_minus)) / (exp(2 * temp * (nei_plus - nei_minus)) + 1)
if (U_vec_step < prog) {
stan[v] <- 1
} else {
stan[v] <- -1
}
return(stan)
}
n <- ncol(graph$nei_matrix)
s_down <- rep(-1, n)
s_up = rep(1, n)
U_vec <- c(runif(1))
k <- 0
memory <- list()
while (k < step) {
stans <- list(s_up, s_down)
U_vec <- append(U_vec, runif(2^(k - 1)))
for (i in 1:2^(k - 1)) {
memory[[length(memory) + 1]] <- list()
}
for (i in (2^k):1) {
# print(i)
stans_new <- list()
for (s in stans) {
# print(s)
memorized <- state_hash(s)
if (is.null(memory[[i]][[as.character(memorized)]])) {
stan <- new_state(s, U_vec[i])
memory[[i]][[as.character(memorized)]] <- stan
stans_new[[length(stans_new) + 1]] <- stan
} else {
stans_new[[length(stans_new) + 1]] <- memory[[i]][[as.character(memorized)]]
}
}
stans <- stans_new
}
k <- k + 1
if (all(stans[[1]] == stans[[2]])) {
if(mem_ret == TRUE) {
return(list(result = stans[[1]], history= memory))
} else {
return(stans[[1]])
}
}
}
}
state_hash(rep(1,16))
code <- state_hash(rep(1,16))
history[[2048]][as.character(code)]
next_s <- history[[2048]][as.character(code)]
next_s
next_s[1]
next_s[2]
next_s[[1]]
next_s[[2]]
next_s <- history[[2048]][as.character(code)][[1]]
next_s
path[[length(path)+1]] <- rep(1,16)
path <- list()
path[[length(path)+1]] <- rep(1,16)
path
history <- ising(temp = 0.3, lattice.gen(4,4), mem_ret = TRUE)$history
code <- state_hash(rep(1,16))
path <- list()
path[[length(path)+1]] <- rep(1,16)
for (i in length(history):1){
next_s <- history[[2048]][as.character(code)][[1]]
path[[length(path)+1]] <- next_s
code <- next_s
}
history <- ising(temp = 0.3, lattice.gen(4,4), mem_ret = TRUE)$history
code <- state_hash(rep(1,16))
path <- list()
path[[length(path)+1]] <- rep(1,16)
for (i in length(history):1){
next_s <- history[[2048]][as.character(code)][[1]]
path[[length(path)+1]] <- next_s
code <- state_hash(next_s)
}
path
history
isi <- ising(temp = 0.3, lattice.gen(4,4), mem_ret = TRUE)
isi
isi$result
history <- isi$history
code <- state_hash(rep(1,16))
path <- list()
path[[length(path)+1]] <- rep(1,16)
for (i in length(history):1){
next_s <- history[[2048]][as.character(code)][[1]]
path[[length(path)+1]] <- next_s
code <- state_hash(next_s)
}
path
path[[8000][]
path[[8000]]
isi$result
history <- isi$history
code <- state_hash(rep(1,16))
path <- list()
path[[length(path)+1]] <- rep(1,16)
for (i in length(history):1){
next_s <- history[[i]][as.character(code)][[1]]
path[[length(path)+1]] <- next_s
code <- state_hash(next_s)
}
path
history
path
path[[1000]]
matrix(path[[1000]], ncol = 4)
heatmap(matrix(path[[1000]], ncol = 4))
install.packages("plot.matrix")
library(plot.matrix)
M.lattice.gen <- function(n_row = 5, n_col = 5, down_spins = 0) {
d <- n_col * n_row
if (down_spins > d) # idk czy dopisywac jakies warunki typu 'argumenty musza byc naturalne' czy cos
{
stop("number of down-spins must be smaller than product of dimensions")
}
v <- rep(1, d)
d_cords <- sample(1:d, down_spins, replace = FALSE)
v[d_cords] <- -1
return(matrix(v, n_row, n_col))
}
M.lattice.gen
M <- M.lattice.gen(10,10,60)
M
X <- matrix(M<0, nrow = 10)
X
plot(X)
heatmap(matrix(path[[1000]]<0, ncol = 4))
matrix(path[[1000]]<0, ncol = 4)
plot(matrix(path[[1000]]<0, ncol = 4))
plot(matrix(path[[1000]]<0, ncol = 4).main = NA)
plot(matrix(path[[1000]]<0, ncol = 4), main = NA)
plot(matrix(path[[1000]]<0, ncol = 4), main = NA,axis.col = NULL, axis.row = NULL, key = NULL)
plot(matrix(path[[1000]]<0, ncol = 4), main = NA,axis.col = NULL, axis.row = NULL, key = NULL,
border = NA, xlab = NA, ylab = NA)
plot(matrix(path[[1000]]<0, ncol = 4), main = NA,axis.col = NULL, axis.row = NULL, key = NULL,
border = NA, xlab = NA, ylab = NA)
length(path)
for (i in 1:length(path)) {
file <- paste0("~/GitHub/LM/R/Wygenerowane obrazki/Gif/obrazek", i, ".png")
png(file, width = 800, height = 600)
plot(matrix(path[[i]]<0, ncol = 4), main = NA,axis.col = NULL, axis.row = NULL, key = NULL,
border = NA, xlab = NA, ylab = NA)
dev.off()
}
isi <- ising(temp = 0.3, lattice.gen(4,4), mem_ret = TRUE)
isi$result
history <- isi$history
history
isi <- ising(temp = 0.3, lattice.gen(4,4), mem_ret = TRUE)
isi$result
history <- isi$history
history
code <- state_hash(rep(1,16))
path <- list()
path[[length(path)+1]] <- rep(1,16)
for (i in length(history):1){
next_s <- history[[i]][as.character(code)][[1]]
path[[length(path)+1]] <- next_s
code <- state_hash(next_s)
}
install.packages("plot.matrix")
library(plot.matrix)
for (i in 1:length(path)) {
file <- paste0("~/GitHub/LM/R/Wygenerowane obrazki/Gif/obrazek", i, ".png")
png(file, width = 800, height = 600)
plot(matrix(path[[i]]<0, ncol = 4), main = NA,axis.col = NULL, axis.row = NULL, key = NULL,
border = NA, xlab = NA, ylab = NA)
dev.off()
}
library(magick)
library(magick)
frames <- paste0("~/GitHub/LM/R/Wygenerowane obrazki/Gif/obrazek0", 1:513, ".png")
m <- image_read(frames)
# ograniczam liczbę obrazków do gif-a ze względu na małą możliwość obliczeniową :(
frames <- paste0("~/GitHub/LM/R/Wygenerowane obrazki/Gif/obrazek0", 1:513, ".png")
m <- image_read(frames)
m <- image_animate(m, fps = 50)
image_write(m, "~/GitHub/LM/R/Wygenerowane obrazki/Gif/movie0.gif")
# Generowanie gif-a dla temp = 0
isi <- ising(temp = 1, lattice.gen(4,4), mem_ret = TRUE)
isi
# Generowanie gif-a dla temp = 0
isi <- ising(temp = 1, lattice.gen(4,4), mem_ret = TRUE)
isi
# Generowanie gif-a dla temp = 0
isi <- ising(temp = 1, lattice.gen(4,4), mem_ret = TRUE)
isi
# Generowanie gif-a dla temp = 0
isi <- ising(temp = 1, lattice.gen(4,4), mem_ret = TRUE)
isi
isi$result
# Generowanie gif-a dla temp = 0
isi <- ising(temp = 1, lattice.gen(4,4), mem_ret = TRUE)
# Generowanie gif-a dla temp = 0
isi <- ising(temp = 1, lattice.gen(4,4), mem_ret = TRUE)
isi
# Generowanie gif-a dla temp = 0
isi <- ising(temp = 1, lattice.gen(4,4), mem_ret = TRUE)
isi
# Generowanie gif-a dla temp = 0
isi <- ising(temp = 1, lattice.gen(4,4), mem_ret = TRUE)
# Generowanie gif-a dla temp = 0
isi <- ising(temp = 1, lattice.gen(4,4), mem_ret = TRUE)
# Generowanie gif-a dla temp = 0
isi <- ising(temp = 1, lattice.gen(4,4), mem_ret = TRUE)
# Generowanie gif-a dla temp = 0
isi <- ising(temp = 1, lattice.gen(4,4), mem_ret = TRUE)
# Generowanie gif-a dla temp = 0
isi <- ising(temp = 1, lattice.gen(4,4), mem_ret = TRUE)
# Generowanie gif-a dla temp = 0
isi <- ising(temp = 1, lattice.gen(4,4), mem_ret = TRUE)
isi
isi$result
# Generowanie gif-a dla temp = 0
isi <- ising(temp = 1, lattice.gen(4,4), mem_ret = TRUE)
isi
# Generowanie gif-a dla temp = 0
isi <- ising(temp = 1, lattice.gen(4,4), mem_ret = TRUE)
isi
# Generowanie gif-a dla temp = 0
isi <- ising(temp = 1, lattice.gen(4,4), mem_ret = TRUE)
# Generowanie gif-a dla temp = 0
isi <- ising(temp = 1, lattice.gen(4,4), mem_ret = TRUE)
# Generowanie gif-a dla temp = 0
isi <- ising(temp = 1, lattice.gen(4,4), mem_ret = TRUE)
# Generowanie gif-a dla temp = 0
isi <- ising(temp = 1, lattice.gen(4,4), mem_ret = TRUE)
# Generowanie gif-a dla temp = 0
isi <- ising(temp = 3, lattice.gen(4,4), mem_ret = TRUE)
# Generowanie gif-a dla temp = 0
isi <- ising(temp = 0.8, lattice.gen(4,4), mem_ret = TRUE)
isi
# Generowanie gif-a dla temp = 0
isi <- ising(temp = 0.8, lattice.gen(4,4), mem_ret = TRUE)
isi
# Generowanie gif-a dla temp = 0
isi <- ising(temp = 0.8, lattice.gen(4,4), mem_ret = TRUE)
isi
# Generowanie gif-a dla temp = 0
isi <- ising(temp = 0.8, lattice.gen(4,4), mem_ret = TRUE)
isi
# Generowanie gif-a dla temp = 0
isi <- ising(temp = 0.8, lattice.gen(4,4), mem_ret = TRUE)
isi
# Generowanie gif-a dla temp = 0
isi <- ising(temp = 0.8, lattice.gen(4,4), mem_ret = TRUE)
isi
# Generowanie gif-a dla temp = 0
isi <- ising(temp = 0.8, lattice.gen(4,4), mem_ret = TRUE)
# Generowanie gif-a dla temp = 0
isi <- ising(temp = 0.8, lattice.gen(4,4), mem_ret = TRUE)
isi
# Generowanie gif-a dla temp = 0
isi <- ising(temp = 0.8, lattice.gen(4,4), mem_ret = TRUE)
isi
# Generowanie gif-a dla temp = 0
isi <- ising(temp = 0.8, lattice.gen(4,4), mem_ret = TRUE)
isi
# Generowanie gif-a dla temp = 0
isi <- ising(temp = 0.8, lattice.gen(4,4), mem_ret = TRUE)
isi
# Generowanie gif-a dla temp = 0
isi <- ising(temp = 0.8, lattice.gen(4,4), mem_ret = TRUE)
# Generowanie gif-a dla temp = 0
isi <- ising(temp = 0.8, lattice.gen(4,4), mem_ret = TRUE)
isi
# Generowanie gif-a dla temp = 0
isi <- ising(temp = 0.8, lattice.gen(4,4), mem_ret = TRUE)
# Generowanie gif-a dla temp = 0
isi <- ising(temp = 0.8, lattice.gen(4,4), mem_ret = TRUE)
isi
isi$result
history <- isi$history
code <- state_hash(rep(1,16))
path <- list()
path[[length(path)+1]] <- rep(1,16)
for (i in length(history):1){
next_s <- history[[i]][as.character(code)][[1]]
path[[length(path)+1]] <- next_s
code <- state_hash(next_s)
}
library(plot.matrix)
for (i in 1:length(path)) {
file <- paste0("~/GitHub/LM/R/Wygenerowane obrazki/Gif/obrazek8", i, ".png")
png(file, width = 800, height = 600)
plot(matrix(path[[i]]<0, ncol = 4),col = c("darkslateblue", "mediumorchid"), main = NA,axis.col = NULL, axis.row = NULL, key = NULL,
border = NA, xlab = NA, ylab = NA)
dev.off()
}
# ograniczam liczbę obrazków do gif-a ze względu na małą możliwość obliczeniową :(
frames <- paste0("~/GitHub/LM/R/Wygenerowane obrazki/Gif/obrazek8", 1:length(path), ".png")
m <- image_read(frames)
library(magick)
m <- image_read(frames)
m <- image_animate(m, fps = 50)
image_write(m, "~/GitHub/LM/R/Wygenerowane obrazki/Gif/movie8.gif")
isi$result
