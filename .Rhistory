graph = lattice.gen(3, 3)
new_state <- function(state, U_vec_step) {
n <- ncol(graph$nei_matrix)
stan <- state
v <- sample(1:n, 1)
nei_plus <- neighbours(graph$nei_matrix[v, ], stan)$nb_plus
nei_minus <- neighbours(graph$nei_matrix[v, ], stan)$nb_minus
prog <- exp(2 * temp * (nei_plus - nei_minus)) / (exp(2 * temp * (nei_plus - nei_minus)) + 1)
if (U_vec_step < prog) {
stan[v] <- 1
} else {
stan[v] <- -1
}
return(stan)
}
n <- ncol(graph$nei_matrix)
s_up <- rep(1, n)
s_down <- rep(-1, n)
stans <- list(s_up, s_down)
U_vec <- c(runif(1))
k <- 0
memory <- list()
while (T) {
U_vec <- append(U_vec, runif(2^(k - 1))) # poprawić
for (i in (2^k):1) {
# print(i)
stans_new <- list()
for (s in stans) {
# print(s)
s_str <- paste(as.character(-i), paste(as.character(s), collapse = ","), collapse = ";")
memorized <- memory[[s_str]]
if (is.null(memorized)) {
stan <- new_state(s, U_vec[i])
memory[[s_str]] <- stan
stans_new[[length(stans_new) + 1]] <- stan
} else {
stans_new[[length(stans_new) + 1]] <- memorized
}
}
stans <- stans_new
}
k <- k + 1
if (all(stans[[1]] == stans[[2]])) {
return(stans[[1]])
}
# memory[[paste(as.character(-1),paste(as.character(s_up), collapse = ','), collapse = ";")]]
}
lattice.gen(10,10)
nei <- graph$nei_matrix
nei
nei[3,]
state <- c(-1,1,-1,1,1,1,-1,1,1)
ct <- table(state[as.logical(nei)])
ct
if (is.na(ct["-1"])) {
ct["-1"] <- 0
}
if (is.na(ct["1"])) {
ct["1"] <- 0
}
list(nb_minus = ct["-1"], nb_plus = ct["1"])
ising <- function(temp = 0.01, graph = lattice.gen(3, 3)) {
new_state <- function(state, U_vec_step) {
n <- ncol(graph$nei_matrix)
stan <- state
v <- sample(1:n, 1)
nei_plus <- neighbours(graph$nei_matrix[v, ], stan)$nb_plus
nei_minus <- neighbours(graph$nei_matrix[v, ], stan)$nb_minus
prog <- exp(2 * temp * (nei_plus - nei_minus)) / (exp(2 * temp * (nei_plus - nei_minus)) + 1)
if (U_vec_step < prog) {
stan[v] <- 1
} else {
stan[v] <- -1
}
return(stan)
}
n <- ncol(graph$nei_matrix)
s_up <- rep(1, n)
s_down <- rep(-1, n)
stans <- list(s_up, s_down)
U_vec <- c(runif(1))
k <- 0
memory <- list()
while (T) {
U_vec <- append(U_vec, runif(2^(k - 1))) # poprawić
for (i in (2^k):1) {
# print(i)
stans_new <- list()
for (s in stans) {
# print(s)
s_str <- paste(as.character(-i), paste(as.character(s), collapse = ","), collapse = ";")
memorized <- memory[[s_str]]
if (is.null(memorized)) {
stan <- new_state(s, U_vec[i])
memory[[s_str]] <- stan
stans_new[[length(stans_new) + 1]] <- stan
} else {
stans_new[[length(stans_new) + 1]] <- memorized
}
}
stans <- stans_new
}
k <- k + 1
if (all(stans[[1]] == stans[[2]])) {
return(stans[[1]])
}
# memory[[paste(as.character(-1),paste(as.character(s_up), collapse = ','), collapse = ";")]]
}
}
complete.graph.gen <- function(n = 5) {
edges <- list()
for (i in 1:(n - 1)) {
for (j in (i + 1):n) {
edges[[length(edges) + 1]] <- c(i, j)
}
}
nei_matrix <- matrix(0, nrow = n, ncol = n)
for (i in 1:length(edges)) {
x <- edges[[i]][1]
y <- edges[[i]][2]
nei_matrix[x, y] <- 1
nei_matrix[y, x] <- 1
}
return(list(edges = edges, nei_matrix = nei_matrix))
}
ising(temp = 0.01, graph = complete.graph.gen(5))
ising(temp = 0.01, graph = complete.graph.gen(10))
ising(temp = 0.01, graph = complete.graph.gen(100))
ising(temp = 0.01, graph = complete.graph.gen(20))
nei
as.logical(nei)
nei <- nei[3,]
nei
as.logical(nei)
ising <- function(temp = 0.01, graph = lattice.gen(3, 3), step = 500000) {
new_state <- function(state, U_vec_step) {
n <- ncol(graph$nei_matrix)
stan <- state
v <- sample(1:n, 1)
nei_plus <- neighbours(graph$nei_matrix[v, ], stan)$nb_plus
nei_minus <- neighbours(graph$nei_matrix[v, ], stan)$nb_minus
prog <- exp(2 * temp * (nei_plus - nei_minus)) / (exp(2 * temp * (nei_plus - nei_minus)) + 1)
if (U_vec_step < prog) {
stan[v] <- 1
} else {
stan[v] <- -1
}
return(stan)
}
n <- ncol(graph$nei_matrix)
s_up <- rep(1, n)
s_down <- rep(-1, n)
stans <- list(s_up, s_down)
U_vec <- c(runif(1))
k <- 0
memory <- list()
while (k < step) {
U_vec <- append(U_vec, runif(2^(k - 1))) # poprawić
for (i in (2^k):1) {
# print(i)
stans_new <- list()
for (s in stans) {
# print(s)
s_str <- paste(as.character(-i), paste(as.character(s), collapse = ","), collapse = ";")
memorized <- memory[[s_str]]
if (is.null(memorized)) {
stan <- new_state(s, U_vec[i])
memory[[s_str]] <- stan
stans_new[[length(stans_new) + 1]] <- stan
} else {
stans_new[[length(stans_new) + 1]] <- memorized
}
}
stans <- stans_new
}
k <- k + 1
if (all(stans[[1]] == stans[[2]])) {
return(stans[[1]])
}
# memory[[paste(as.character(-1),paste(as.character(s_up), collapse = ','), collapse = ";")]]
}
}
ising(temp = 0.01, graph = lattice.gen(4,4))
ising(temp = 0.01, graph = lattice.gen(4,4))
ising(temp = 0.01, graph = lattice.gen(3,3))
ising(temp = 0.01, graph = complete.graph.gen(10))
state[as.logical(nei)]
neighbours <- function(nei, state) {
nb_minus <- 0
nb_plus <- 0
if (i in state[as.logical(nei)]==1){
state[as.logical(nei)]
neighbours <- function(nei, state) {
nb_minus <- 0
nb_plus <- 0
for (i in state[as.logical(nei)]){
if (i==1){
nb_plus <- nb_plus + 1
} else{
nb_minus <- nb_minus + 1
}
}
list(nb_minus = nb_minus, nb_plus = nb_plus)
}
nei
neighbours(nei, state)
ising <- function(temp = 0.01, graph = lattice.gen(3, 3), step = 500000) {
new_state <- function(state, U_vec_step) {
n <- ncol(graph$nei_matrix)
stan <- state
v <- sample(1:n, 1)
nei_plus <- neighbours(graph$nei_matrix[v, ], stan)$nb_plus
nei_minus <- neighbours(graph$nei_matrix[v, ], stan)$nb_minus
prog <- exp(2 * temp * (nei_plus - nei_minus)) / (exp(2 * temp * (nei_plus - nei_minus)) + 1)
if (U_vec_step < prog) {
stan[v] <- 1
} else {
stan[v] <- -1
}
return(stan)
}
n <- ncol(graph$nei_matrix)
s_up <- rep(1, n)
s_down <- rep(-1, n)
stans <- list(s_up, s_down)
U_vec <- c(runif(1))
k <- 0
memory <- list()
while (k < step) {
U_vec <- append(U_vec, runif(2^(k - 1))) # poprawić
for (i in (2^k):1) {
# print(i)
stans_new <- list()
for (s in stans) {
# print(s)
s_str <- paste(as.character(-i), paste(as.character(s), collapse = ","), collapse = ";")
memorized <- memory[[s_str]]
if (is.null(memorized)) {
stan <- new_state(s, U_vec[i])
memory[[s_str]] <- stan
stans_new[[length(stans_new) + 1]] <- stan
} else {
stans_new[[length(stans_new) + 1]] <- memorized
}
}
stans <- stans_new
}
k <- k + 1
if (all(stans[[1]] == stans[[2]])) {
return(stans[[1]])
}
# memory[[paste(as.character(-1),paste(as.character(s_up), collapse = ','), collapse = ";")]]
}
}
ising(0.01, lattice.gen(3,3))
ising(0.01, lattice.gen(4,4))
ising(0.01, lattice.gen(3,3))
ising(0.01, lattice.gen(3,4))
ising(0.01, lattice.gen(4,4))
ising(0.01, lattice.gen(5,5))
ising(0.01, lattice.gen(5,4))
ising(0.01, lattice.gen(4,4))
ising(0.01, lattice.gen(3,4))
ising(0.01, lattice.gen(3,4))
ising <- function(temp = 0.01, graph = lattice.gen(3, 3), step = 10000) {
new_state <- function(state, U_vec_step) {
n <- ncol(graph$nei_matrix)
stan <- state
v <- sample(1:n, 1)
nei_plus <- neighbours(graph$nei_matrix[v, ], stan)$nb_plus
nei_minus <- neighbours(graph$nei_matrix[v, ], stan)$nb_minus
prog <- exp(2 * temp * (nei_plus - nei_minus)) / (exp(2 * temp * (nei_plus - nei_minus)) + 1)
if (U_vec_step < prog) {
stan[v] <- 1
} else {
stan[v] <- -1
}
return(stan)
}
n <- ncol(graph$nei_matrix)
s_up <- rep(1, n)
s_down <- rep(-1, n)
stans <- list(s_up, s_down)
U_vec <- c(runif(1))
k <- 0
memory <- list()
while (k < step) {
U_vec <- append(U_vec, runif(2^(k - 1))) # poprawić
for (i in (2^k):1) {
# print(i)
stans_new <- list()
for (s in stans) {
# print(s)
s_str <- paste(as.character(-i), paste(as.character(s), collapse = ","), collapse = ";")
memorized <- memory[[s_str]]
if (is.null(memorized)) {
stan <- new_state(s, U_vec[i])
memory[[s_str]] <- stan
stans_new[[length(stans_new) + 1]] <- stan
} else {
stans_new[[length(stans_new) + 1]] <- memorized
}
}
stans <- stans_new
}
k <- k + 1
if (all(stans[[1]] == stans[[2]])) {
return(stans[[1]])
}
# memory[[paste(as.character(-1),paste(as.character(s_up), collapse = ','), collapse = ";")]]
}
}
ising(0.01, lattice.gen(3,4))
ising(0.01, lattice.gen(4,4))
ising <- function(temp = 0.01, graph = lattice.gen(3, 3), step = 10) {
new_state <- function(state, U_vec_step) {
n <- ncol(graph$nei_matrix)
stan <- state
v <- sample(1:n, 1)
nei_plus <- neighbours(graph$nei_matrix[v, ], stan)$nb_plus
nei_minus <- neighbours(graph$nei_matrix[v, ], stan)$nb_minus
prog <- exp(2 * temp * (nei_plus - nei_minus)) / (exp(2 * temp * (nei_plus - nei_minus)) + 1)
if (U_vec_step < prog) {
stan[v] <- 1
} else {
stan[v] <- -1
}
return(stan)
}
n <- ncol(graph$nei_matrix)
s_up <- rep(1, n)
s_down <- rep(-1, n)
stans <- list(s_up, s_down)
U_vec <- c(runif(1))
k <- 0
memory <- list()
while (k < step) {
U_vec <- append(U_vec, runif(2^(k - 1))) # poprawić
for (i in (2^k):1) {
# print(i)
stans_new <- list()
for (s in stans) {
# print(s)
s_str <- paste(as.character(-i), paste(as.character(s), collapse = ","), collapse = ";")
memorized <- memory[[s_str]]
if (is.null(memorized)) {
stan <- new_state(s, U_vec[i])
memory[[s_str]] <- stan
stans_new[[length(stans_new) + 1]] <- stan
} else {
stans_new[[length(stans_new) + 1]] <- memorized
}
}
stans <- stans_new
}
k <- k + 1
if (all(stans[[1]] == stans[[2]])) {
return(stans[[1]])
}
# memory[[paste(as.character(-1),paste(as.character(s_up), collapse = ','), collapse = ";")]]
}
}
ising(0.01, lattice.gen(4,4))
ising(0.01, lattice.gen(4,4))
ising <- function(temp = 0.01, graph = lattice.gen(3, 3), step = 100) {
new_state <- function(state, U_vec_step) {
n <- ncol(graph$nei_matrix)
stan <- state
v <- sample(1:n, 1)
nei_plus <- neighbours(graph$nei_matrix[v, ], stan)$nb_plus
nei_minus <- neighbours(graph$nei_matrix[v, ], stan)$nb_minus
prog <- exp(2 * temp * (nei_plus - nei_minus)) / (exp(2 * temp * (nei_plus - nei_minus)) + 1)
if (U_vec_step < prog) {
stan[v] <- 1
} else {
stan[v] <- -1
}
return(stan)
}
n <- ncol(graph$nei_matrix)
s_up <- rep(1, n)
s_down <- rep(-1, n)
stans <- list(s_up, s_down)
U_vec <- c(runif(1))
k <- 0
memory <- list()
while (k < step) {
U_vec <- append(U_vec, runif(2^(k - 1))) # poprawić
for (i in (2^k):1) {
# print(i)
stans_new <- list()
for (s in stans) {
# print(s)
s_str <- paste(as.character(-i), paste(as.character(s), collapse = ","), collapse = ";")
memorized <- memory[[s_str]]
if (is.null(memorized)) {
stan <- new_state(s, U_vec[i])
memory[[s_str]] <- stan
stans_new[[length(stans_new) + 1]] <- stan
} else {
stans_new[[length(stans_new) + 1]] <- memorized
}
}
stans <- stans_new
}
k <- k + 1
if (all(stans[[1]] == stans[[2]])) {
return(stans[[1]])
}
# memory[[paste(as.character(-1),paste(as.character(s_up), collapse = ','), collapse = ";")]]
}
}
ising(0.01, lattice.gen(4,4))
ising(0.01, lattice.gen(4,5))
temp = 0.01
graph = lattice.gen(3, 3)
step = 10000
new_state <- function(state, U_vec_step) {
n <- ncol(graph$nei_matrix)
stan <- state
v <- sample(1:n, 1)
nei_plus <- neighbours(graph$nei_matrix[v, ], stan)$nb_plus
nei_minus <- neighbours(graph$nei_matrix[v, ], stan)$nb_minus
prog <- exp(2 * temp * (nei_plus - nei_minus)) / (exp(2 * temp * (nei_plus - nei_minus)) + 1)
if (U_vec_step < prog) {
stan[v] <- 1
} else {
stan[v] <- -1
}
return(stan)
}
n <- ncol(graph$nei_matrix)
s_up <- rep(1, n)
s_down <- rep(-1, n)
stans <- list(s_up, s_down)
U_vec <- c(runif(1))
k <- 0
memory <- list()
while (k < step) {
U_vec <- append(U_vec, runif(2^(k - 1))) # poprawić
for (i in (2^k):1) {
print(i)
stans_new <- list()
for (s in stans) {
# print(s)
s_str <- paste(as.character(-i), paste(as.character(s), collapse = ","), collapse = ";")
memorized <- memory[[s_str]]
if (is.null(memorized)) {
stan <- new_state(s, U_vec[i])
memory[[s_str]] <- stan
stans_new[[length(stans_new) + 1]] <- stan
} else {
stans_new[[length(stans_new) + 1]] <- memorized
}
}
stans <- stans_new
}
k <- k + 1
if (all(stans[[1]] == stans[[2]])) {
return(stans[[1]])
}
# memory[[paste(as.character(-1),paste(as.character(s_up), collapse = ','), collapse = ";")]]
}
temp = 0.01
graph = lattice.gen(4, 4)
step = 10000
new_state <- function(state, U_vec_step) {
n <- ncol(graph$nei_matrix)
stan <- state
v <- sample(1:n, 1)
nei_plus <- neighbours(graph$nei_matrix[v, ], stan)$nb_plus
nei_minus <- neighbours(graph$nei_matrix[v, ], stan)$nb_minus
prog <- exp(2 * temp * (nei_plus - nei_minus)) / (exp(2 * temp * (nei_plus - nei_minus)) + 1)
if (U_vec_step < prog) {
stan[v] <- 1
} else {
stan[v] <- -1
}
return(stan)
}
n <- ncol(graph$nei_matrix)
s_up <- rep(1, n)
s_down <- rep(-1, n)
stans <- list(s_up, s_down)
U_vec <- c(runif(1))
k <- 0
memory <- list()
while (k < step) {
U_vec <- append(U_vec, runif(2^(k - 1))) # poprawić
for (i in (2^k):1) {
print(i)
stans_new <- list()
for (s in stans) {
# print(s)
s_str <- paste(as.character(-i), paste(as.character(s), collapse = ","), collapse = ";")
memorized <- memory[[s_str]]
if (is.null(memorized)) {
stan <- new_state(s, U_vec[i])
memory[[s_str]] <- stan
stans_new[[length(stans_new) + 1]] <- stan
} else {
stans_new[[length(stans_new) + 1]] <- memorized
}
}
stans <- stans_new
}
k <- k + 1
if (all(stans[[1]] == stans[[2]])) {
return(stans[[1]])
}
# memory[[paste(as.character(-1),paste(as.character(s_up), collapse = ','), collapse = ";")]]
}
