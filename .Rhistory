s_down <- rep(-1,n)
stans <- list(s_up, s_down)
U_vec <- c(runif(1))
k <- 0
memory <- list()
while(k < 10) {
U_vec <- append(U_vec, runif(2^(k-1))) # poprawić
for (i in (2^k):1){
#print(i)
stans_new <- list()
for (s in stans){
#print(s)
s_str <- paste(as.character(-i),paste(as.character(s), collapse = ','), collapse = ";")
memorized <- memory[[s_str]]
if (is.null(memorized)){
stan <- new_state(s, U_vec[i])
memory[[s_str]] <- stan
stans_new[[length(stans_new)+1]] <- stan
} else {
stans_new[[length(stans_new)+1]] <- memorized
}
}
stans <- stans_new
}
k <- k+1
#memory[[paste(as.character(-1),paste(as.character(s_up), collapse = ','), collapse = ";")]]
}
memory
prog <- exp(2*temp*(nei_plus-nei_minus))/(exp(2*temp*(nei_plus-nei_minus))+1)
lattice.gen <- function(n_row = 3, n_col = 3) {
n <- n_row * n_col
nr_ver <- 1:n
edges <- list()
for (j in 1:n_col) {
for (i in 1:(n_row - 1)) {
edges[[length(edges) + 1]] <- c(j + (i - 1) * n_col, j + i * n_col)
}
}
for (i in 1:n_row) {
for (j in 1:(n_col - 1)) {
edges[[length(edges) + 1]] <- c(j + (i - 1) * n_col, j + (i - 1) * n_col + 1)
}
}
nei_matrix <- matrix(0, nrow = n, ncol = n)
for (i in 1:length(edges)) {
x <- edges[[i]][1]
y <- edges[[i]][2]
nei_matrix[x, y] <- 1
nei_matrix[y, x] <- 1
}
return(list(edges = edges, nei_matrix = nei_matrix))
}
temp = 0.01
graph = lattice.gen(5,5)
new_state <- function(state,  U_vec_step){
n <- ncol(graph$nei_matrix)
stan <- state
for (v in 1:n){
nei_plus <- neighbours(graph$nei_matrix[v,], stan)$nb_plus
nei_minus <- neighbours(graph$nei_matrix[v,], stan)$nb_minus
prog <- exp(2*temp*(nei_plus-nei_minus))/(exp(2*temp*(nei_plus-nei_minus))+1)
if (U_vec_step<prog) {
stan[v] <- 1
} else{
stan[v] <- -1
}
}
return(stan)
}
n <- ncol(graph$nei_matrix)
s_up <- rep(1,n)
s_down <- rep(-1,n)
stans <- list(s_up, s_down)
U_vec <- c(runif(1))
k <- 0
memory <- list()
while(k < 10) {
U_vec <- append(U_vec, runif(2^(k-1))) # poprawić
for (i in (2^k):1){
#print(i)
stans_new <- list()
for (s in stans){
#print(s)
s_str <- paste(as.character(-i),paste(as.character(s), collapse = ','), collapse = ";")
memorized <- memory[[s_str]]
if (is.null(memorized)){
stan <- new_state(s, U_vec[i])
memory[[s_str]] <- stan
stans_new[[length(stans_new)+1]] <- stan
} else {
stans_new[[length(stans_new)+1]] <- memorized
}
}
stans <- stans_new
}
k <- k+1
#memory[[paste(as.character(-1),paste(as.character(s_up), collapse = ','), collapse = ";")]]
}
memory
ising <- function(temp = 0.01, graph = lattice.gen(3,3)) {
new_state <- function(state,  U_vec_step){
n <- ncol(graph$nei_matrix)
stan <- state
v <- sample(1:n, 1)
nei_plus <- neighbours(graph$nei_matrix[v,], stan)$nb_plus
nei_minus <- neighbours(graph$nei_matrix[v,], stan)$nb_minus
prog <- exp(2*temp*(nei_plus-nei_minus))/(exp(2*temp*(nei_plus-nei_minus))+1)
if (U_vec_step<prog) {
stan[v] <- 1
} else{
stan[v] <- -1
}
return(stan)
}
n <- ncol(graph$nei_matrix)
s_up <- rep(1,n)
s_down <- rep(-1,n)
stans <- list(s_up, s_down)
U_vec <- c(runif(1))
k <- 0
memory <- list()
while(T) {
U_vec <- append(U_vec, runif(2^(k-1))) # poprawić
for (i in (2^k):1){
#print(i)
stans_new <- list()
for (s in stans){
#print(s)
s_str <- paste(as.character(-i),paste(as.character(s), collapse = ','), collapse = ";")
memorized <- memory[[s_str]]
if (is.null(memorized)){
stan <- new_state(s, U_vec[i])
memory[[s_str]] <- stan
stans_new[[length(stans_new)+1]] <- stan
} else {
stans_new[[length(stans_new)+1]] <- memorized
}
}
stans <- stans_new
}
k <- k+1
if(all(stans[[1]]==stans[[2]])){
return(stans[[1]])
}
#memory[[paste(as.character(-1),paste(as.character(s_up), collapse = ','), collapse = ";")]]
}
}
ising(temp = 0.4)
lattice.gen <- function(n_row = 3, n_col = 3) {
n <- n_row * n_col
nr_ver <- 1:n
edges <- list()
for (j in 1:n_col) {
for (i in 1:(n_row - 1)) {
edges[[length(edges) + 1]] <- c(j + (i - 1) * n_col, j + i * n_col)
}
}
for (i in 1:n_row) {
for (j in 1:(n_col - 1)) {
edges[[length(edges) + 1]] <- c(j + (i - 1) * n_col, j + (i - 1) * n_col + 1)
}
}
nei_matrix <- matrix(0, nrow = n, ncol = n)
for (i in 1:length(edges)) {
x <- edges[[i]][1]
y <- edges[[i]][2]
nei_matrix[x, y] <- 1
nei_matrix[y, x] <- 1
}
return(list(edges = edges, nei_matrix = nei_matrix))
}
neighbours <- function(nei, state) {
ct <- table(state[as.logical(nei)])
if (is.na(ct['-1'])){
ct['-1'] <- 0
}
if (is.na(ct['1'])){
ct['1'] <- 0
}
list(nb_minus = ct['-1'], nb_plus = ct['1'])
}
ising <- function(temp = 0.01, graph = lattice.gen(3,3)) {
new_state <- function(state,  U_vec_step){
n <- ncol(graph$nei_matrix)
stan <- state
v <- sample(1:n, 1)
nei_plus <- neighbours(graph$nei_matrix[v,], stan)$nb_plus
nei_minus <- neighbours(graph$nei_matrix[v,], stan)$nb_minus
prog <- exp(2*temp*(nei_plus-nei_minus))/(exp(2*temp*(nei_plus-nei_minus))+1)
if (U_vec_step<prog) {
stan[v] <- 1
} else{
stan[v] <- -1
}
return(stan)
}
n <- ncol(graph$nei_matrix)
s_up <- rep(1,n)
s_down <- rep(-1,n)
stans <- list(s_up, s_down)
U_vec <- c(runif(1))
k <- 0
memory <- list()
while(T) {
U_vec <- append(U_vec, runif(2^(k-1))) # poprawić
for (i in (2^k):1){
#print(i)
stans_new <- list()
for (s in stans){
#print(s)
s_str <- paste(as.character(-i),paste(as.character(s), collapse = ','), collapse = ";")
memorized <- memory[[s_str]]
if (is.null(memorized)){
stan <- new_state(s, U_vec[i])
memory[[s_str]] <- stan
stans_new[[length(stans_new)+1]] <- stan
} else {
stans_new[[length(stans_new)+1]] <- memorized
}
}
stans <- stans_new
}
k <- k+1
if(all(stans[[1]]==stans[[2]])){
return(stans[[1]])
}
#memory[[paste(as.character(-1),paste(as.character(s_up), collapse = ','), collapse = ";")]]
}
}
ising(temp = 0.4)
ising(temp = 0.1)
ising(temp = 0.3)
ising(temp = 0.01)
neighbours <- function(nei, state) {
ct <- table(state[as.logical(nei)])
if (is.na(ct['-1'])){
ct['-1'] <- 0
}
if (is.na(ct['1'])){
ct['1'] <- 0
}
list(nb_minus = ct['-1'], nb_plus = ct['1'])
}
lattice.gen <- function(n_row = 3, n_col = 3) {
n <- n_row * n_col
nr_ver <- 1:n
edges <- list()
for (j in 1:n_col) {
for (i in 1:(n_row - 1)) {
edges[[length(edges) + 1]] <- c(j + (i - 1) * n_col, j + i * n_col)
}
}
for (i in 1:n_row) {
for (j in 1:(n_col - 1)) {
edges[[length(edges) + 1]] <- c(j + (i - 1) * n_col, j + (i - 1) * n_col + 1)
}
}
nei_matrix <- matrix(0, nrow = n, ncol = n)
for (i in 1:length(edges)) {
x <- edges[[i]][1]
y <- edges[[i]][2]
nei_matrix[x, y] <- 1
nei_matrix[y, x] <- 1
}
return(list(edges = edges, nei_matrix = nei_matrix))
}
# krata <- lattice.gen(7, 10, 32)
krata <- lattice.gen(2, 3)
krata$edges
krata$nei_matrix
ising <- function(temp = 0.01, graph = lattice.gen(3,3)) {
new_state <- function(state,  U_vec_step){
n <- ncol(graph$nei_matrix)
stan <- state
v <- sample(1:n, 1)
nei_plus <- neighbours(graph$nei_matrix[v,], stan)$nb_plus
nei_minus <- neighbours(graph$nei_matrix[v,], stan)$nb_minus
prog <- exp(2*temp*(nei_plus-nei_minus))/(exp(2*temp*(nei_plus-nei_minus))+1)
if (U_vec_step<prog) {
stan[v] <- 1
} else{
stan[v] <- -1
}
return(stan)
}
n <- ncol(graph$nei_matrix)
s_up <- rep(1,n)
s_down <- rep(-1,n)
stans <- list(s_up, s_down)
U_vec <- c(runif(1))
k <- 0
memory <- list()
while(T) {
U_vec <- append(U_vec, runif(2^(k-1))) # poprawić
for (i in (2^k):1){
#print(i)
stans_new <- list()
for (s in stans){
#print(s)
s_str <- paste(as.character(-i),paste(as.character(s), collapse = ','), collapse = ";")
memorized <- memory[[s_str]]
if (is.null(memorized)){
stan <- new_state(s, U_vec[i])
memory[[s_str]] <- stan
stans_new[[length(stans_new)+1]] <- stan
} else {
stans_new[[length(stans_new)+1]] <- memorized
}
}
stans <- stans_new
}
k <- k+1
if(all(stans[[1]]==stans[[2]])){
return(stans[[1]])
}
#memory[[paste(as.character(-1),paste(as.character(s_up), collapse = ','), collapse = ";")]]
}
}
ising(temp = 0.4)
styler::style_file()
styler::style_pkg()
ising(temp = 10)
ising(temp = 10)
ising(temp = 1)
ising(temp = 5)
ising(temp = 2)
ising(temp = 0.4)
ising(temp = 0.7)
ising(temp = 0)
ising(temp = 1)
lattice.gen <- function(n_row = 3, n_col = 3) {
n <- n_row * n_col
nr_ver <- 1:n
edges <- list()
for (j in 1:n_col) {
for (i in 1:(n_row - 1)) {
edges[[length(edges) + 1]] <- c(j + (i - 1) * n_col, j + i * n_col)
}
}
for (i in 1:n_row) {
for (j in 1:(n_col - 1)) {
edges[[length(edges) + 1]] <- c(j + (i - 1) * n_col, j + (i - 1) * n_col + 1)
}
}
nei_matrix <- matrix(0, nrow = n, ncol = n)
for (i in 1:length(edges)) {
x <- edges[[i]][1]
y <- edges[[i]][2]
nei_matrix[x, y] <- 1
nei_matrix[y, x] <- 1
}
return(list(edges = edges, nei_matrix = nei_matrix))
}
neighbours <- function(nei, state) {
ct <- table(state[as.logical(nei)])
if (is.na(ct["-1"])) {
ct["-1"] <- 0
}
if (is.na(ct["1"])) {
ct["1"] <- 0
}
list(nb_minus = ct["-1"], nb_plus = ct["1"])
}
ising <- function(temp = 0.01, graph = lattice.gen(3, 3)) {
new_state <- function(state, U_vec_step) {
n <- ncol(graph$nei_matrix)
stan <- state
v <- sample(1:n, 1)
nei_plus <- neighbours(graph$nei_matrix[v, ], stan)$nb_plus
nei_minus <- neighbours(graph$nei_matrix[v, ], stan)$nb_minus
prog <- exp(2 * temp * (nei_plus - nei_minus)) / (exp(2 * temp * (nei_plus - nei_minus)) + 1)
if (U_vec_step < prog) {
stan[v] <- 1
} else {
stan[v] <- -1
}
return(stan)
}
n <- ncol(graph$nei_matrix)
s_up <- rep(1, n)
s_down <- rep(-1, n)
stans <- list(s_up, s_down)
U_vec <- c(runif(1))
k <- 0
memory <- list()
while (T) {
U_vec <- append(U_vec, runif(2^(k - 1))) # poprawić
for (i in (2^k):1) {
# print(i)
stans_new <- list()
for (s in stans) {
# print(s)
s_str <- paste(as.character(-i), paste(as.character(s), collapse = ","), collapse = ";")
memorized <- memory[[s_str]]
if (is.null(memorized)) {
stan <- new_state(s, U_vec[i])
memory[[s_str]] <- stan
stans_new[[length(stans_new) + 1]] <- stan
} else {
stans_new[[length(stans_new) + 1]] <- memorized
}
}
stans <- stans_new
}
k <- k + 1
if (all(stans[[1]] == stans[[2]])) {
return(stans[[1]])
}
# memory[[paste(as.character(-1),paste(as.character(s_up), collapse = ','), collapse = ";")]]
}
}
ising(temp = 1)
ising(temp = 4)
ising(temp = 0.5)
ising(temp = 0.4)
ising(temp = 0.1)
ising(temp = 0.2)
ising(temp = 0.04)
ising(temp = 0)
ising(temp = 1.2)
ising(temp = 2)
ising(temp = 0.4)
ising(temp = 0.4, graph = lattice.gen(10,10))
lattice.gen(10,10)
lattice.gen(3,3)
lattice.gen(10,10)
ising(temp = 0.4, graph = lattice.gen(10,10))
ising(temp = 0.01, graph = lattice.gen(10,10))
ising(temp = 0.01, graph = lattice.gen(3,3))
ising(temp = 0.01, graph = lattice.gen(4,4))
ising(temp = 0.01, graph = lattice.gen(5,5))
ising(temp = 0.01, graph = lattice.gen(3,3))
res <- ising(temp = 0.01, graph = lattice.gen(3,3))
plot(res)
matplot(res)
heatmap(res)
matrix(res, ncol = 3)
heatmap(matrix(res, ncol = 3))
library(ggplot2)
data <- matrix(res, ncol = 3)
x <- LETTERS[1:20]
y <- paste0("var", seq(1,20))
data$Z <- runif(400, 0, 5)
ggplot(data, aes(X, Y, fill= Z)) +
geom_tile()
x <- 1:3
y <- 1:3
data <- expand.grid(X=x, Y=y)
data
x <- 1:3
y <- 1:3
data <- expand.grid(X=x, Y=y)
data$Z <- res
ggplot(res, aes(X, Y, fill= Z)) +
geom_tile()
data
data.frame(data)
data <- data.frame(data)
ggplot(res, aes(X, Y, fill= Z)) +
geom_tile()
ggplot(data, aes(X, Y, fill= Z)) +
geom_tile()
for (i in 1:10){
res <- ising(temp = 0.01, graph = lattice.gen(3,3))
data$Z <- res
data <- data.frame(data)
ggplot(data, aes(X, Y, fill= Z)) +
geom_tile()
}
for (i in 1:10){
res[i] <- ising(temp = 0.01, graph = lattice.gen(3,3))
}
res <- c()
for (i in 1:10){
res[i] <- ising(temp = 0.01, graph = lattice.gen(3,3))
}
res
for (i in 1:10){
res[[length(res)+1]] <- ising(temp = 0.01, graph = lattice.gen(3,3))
}
res <- list()
for (i in 1:10){
res[[length(res)+1]] <- ising(temp = 0.01, graph = lattice.gen(3,3))
}
data$Z <- res[[1]]
data <- data.frame(data)
ggplot(data, aes(X, Y, fill= Z)) +
geom_tile()
data$Z <- res[[2]]
data <- data.frame(data)
ggplot(data, aes(X, Y, fill= Z)) +
geom_tile()
data$Z <- res[[3]]
data <- data.frame(data)
ggplot(data, aes(X, Y, fill= Z)) +
geom_tile()
data$Z <- res[[4]]
data <- data.frame(data)
ggplot(data, aes(X, Y, fill= Z)) +
geom_tile()
data$Z <- res[[5]]
data <- data.frame(data)
ggplot(data, aes(X, Y, fill= Z)) +
geom_tile()
data$Z <- res[[6]]
data <- data.frame(data)
ggplot(data, aes(X, Y, fill= Z)) +
geom_tile()
data$Z <- res[[7]]
data <- data.frame(data)
ggplot(data, aes(X, Y, fill= Z)) +
geom_tile()
